WHITESPACE = _{ " " | "\n" }
COMMENT = { "//" ~ (!"//" ~ ANY)* ~ "//" }

pharos = _{SOI ~ (function_block
| codeblock 
| statement
| expression
)* ~ EOI}

codeblock = {"{" ~ (statement | expression)+ ~ "}"}

expression = {number | boolean | function_call | identifier | logic | binop_math}

statement = {print | assignment | if_statement | loops}

function_block = {"function" ~ identifier ~ ("inputs" ~ identifier ~ ("," ~ identifier)*)? ~ codeblock}

if_statement = {"if" ~ logic ~ codeblock ~ (else_if_statement | else_statement)*}

else_if_statement = {"else if" ~ logic ~ codeblock ~ (else_statement)*}

else_statement = {"else" ~ codeblock}

loops = {"loop" ~ ( ("until" ~ logic) | (number ~ "times")) ~ codeblock }

while_loop = {""}

assignment = {"let" ~ identifier ~"=" ~ primitive_data_type}

print = {("output"| "out" | "print") ~ string }

primitive_data_type = {number | string | boolean}

logic = {(binop_logic | uniop_logical)}

binop_logic = {
    "(" ~ expression ~ (bin_logical_operators) ~ expression ~ ")"
}

binop_math = {
    "(" ~ expression ~ (bin_math_operators) ~ expression ~ ")"
}

uniop_logical = {
    l_op_nt ~ expression
}

bin_logical_operators = {
    (l_op_ge) | (l_op_le) | (l_op_ne) |
    (l_op_eq) | (l_op_gt) | (l_op_lt) |
    (l_op_or) | (l_op_and)
}

l_op_ge = { (">=") | ("is greater than or equal to")}
l_op_le = { ("<=") | ("is less than or equal to")}
l_op_ne = { ("!=") | ("is not equal to")}
l_op_eq = { ("==") | ("is equal to") }
l_op_gt = { (">")  | ("is greater than")}
l_op_lt = { ("<")  | ("is less than")}
l_op_or = { ("||") | ("or") }
l_op_and = { ("&&") | ("and") }
l_op_nt = {("!") | "not"}


bin_math_operators = {
    (m_op_add) | (m_op_sub) | (m_op_mul) |
    (m_op_mul) | (m_op_by) | (m_op_mod) 
}

m_op_add = { ("+") | ("plus")}
m_op_sub = { ("-") | ("minus")}
m_op_mul = { ("*") | ("times")}
m_op_by = { ("/") | ("divided by")}
m_op_mod = { ("%") | ("modulus")}

// primitive data types for expressions

keywords = {("false" | "true" | "plus" | "function" | "inputs" | "else if"
| "else" | "if" | "loop" | "until" | "times" | "let" | "output"| "out" | "print" |  "not" | "and"| "or"
| "plus" | "minus" | "times" | "divided by" | "modulus" ) ~ WHITESPACE}

identifier = @{ !("\"" | keywords) ~ (ASCII_ALPHA | ("_")) ~ (ASCII_ALPHANUMERIC | ("_"))* }

function_call = {(identifier ~ "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")")}

number = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)?
}

boolean = {"false" | "true"}

string = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = {
    !("\"" | "\\" | "//") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}


// JSON grammar for reference 
// WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
// object = {
//     "{" ~  null ~"}" |
//     "{" ~ pair ~ ("," ~ pair)* ~ "}"
// }
// pair = { string ~ ":" ~ value }

// array = {
// //    "[" ~ "]" |
//     "[" ~ value ~ ("," ~ value)* ~ "]"
// }
// value = _{ object | array | string | number | boolean | null | logical_binop}

// logical_binop = {
//     "(" ~ value ~ (">" | "<" | "==") ~ value ~ ")"
// }

// boolean = { "true" | "false" }

// null = { "null" }

// string = ${ "\"" ~ inner ~ "\"" }
// inner = @{ char* }
// char = {
//     !("\"" | "\\") ~ ANY
//     | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
//     | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
// }

// number = @{
//     "-"?
//     ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
//     ~ ("." ~ ASCII_DIGIT*)?
//     ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
// }

// json = _{ SOI ~ (object | array | logical_binop)* ~ EOI }