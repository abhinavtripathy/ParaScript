WHITESPACE = _{ " " | "\n" }
COMMENT = { "//" ~ (!"//" ~ ANY)* ~ "//" }

pharos = _{SOI ~ (
 statement
| expression // This is only temporary, with the exception of function calls there should be no stand alone  expressions in the code
)* ~ EOI}

// pharos = _{SOI ~ (
// | statement
// | function_call
// )* ~ EOI}

code = {(statement | function_call)}

codeblock = _{"{" ~ code+ ~ "}"}

expression = {number | boolean | string | function_call | identifier | binop_logic | binop_math | uniop_logical}

statement = {function_block | print | assignment | if_statement | loops | return_statment}

return_statment = {"return" ~ expression?}

function_block = {"function" ~ identifier ~ ("inputs" ~ identifier ~ ("," ~ identifier)*)? ~ codeblock}

function_call = {(identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")")}

if_statement = {"if" ~ logic ~ codeblock ~ (else_if_statement | else_statement)*}

else_if_statement = {"else if" ~ logic ~ codeblock ~ (else_statement)*}

else_statement = {"else" ~ codeblock}

loops = {"loop" ~ ( ("until" ~ logic) | (number ~ "times")) ~ codeblock }

assignment = {"let" ~ identifier ~"=" ~ primitive_data_type}

print = {("output"| "out" | "print") ~  "(" ~ ( (string | expression) ~ ("," ~ (string | expression))*)? ~ ")"}

primitive_data_type = {number | string | boolean}

logic = _{(binop_logic | uniop_logical)}

binop_logic = {
    "(" ~ expression ~ (bin_logical_operators) ~ expression ~ ")"
}

binop_math = {
    "(" ~ expression ~ (bin_math_operators) ~ expression ~ ")"
}

uniop_logical = {
    l_op_nt ~ expression
}

bin_logical_operators = {
    (l_op_ge) | (l_op_le) | (l_op_ne) |
    (l_op_eq) | (l_op_gt) | (l_op_lt) |
    (l_op_or) | (l_op_and)
}

l_op_ge = _{ (">=") | ("is greater than or equal to")}
l_op_le = _{ ("<=") | ("is less than or equal to")}
l_op_ne = _{ ("!=") | ("is not equal to")}
l_op_eq = _{ ("==") | ("is equal to") }
l_op_gt = _{ (">")  | ("is greater than")}
l_op_lt = _{ ("<")  | ("is less than")}
l_op_or = _{ ("||") | ("or") }
l_op_and = _{ ("&&") | ("and") }
l_op_nt = _{("!") | "not"}


bin_math_operators = {
    (m_op_add) | (m_op_sub) | (m_op_mul) |
    (m_op_mul) | (m_op_by) | (m_op_mod) 
}

m_op_add = { ("+") | ("plus")}
m_op_sub = { ("-") | ("minus")}
m_op_mul = { ("*") | ("times")}
m_op_by = { ("/") | ("divided by")}
m_op_mod = { ("%") | ("mod")}

// primitive data types for expressions

keywords = _{("false" | "true" | "plus" | "function" | "inputs" | "else if"
| "else" | "if" | "loop" | "until" | "times" | "let" | "output"| "out" | "print" |  "not" | "and"| "or"
| "plus" | "minus" | "times" | "divided by" | "mod" | "return" ) ~ WHITESPACE}

identifier = @{ !("\"" | keywords) ~ (ASCII_ALPHA | ("_")) ~ (ASCII_ALPHANUMERIC | ("_"))* }

number = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)?
}

boolean = {"false" | "true"}

string = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = _{
    !("\"" | "\\" | "//") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}


// JSON grammar for reference 
// WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
// object = {
//     "{" ~  null ~"}" |
//     "{" ~ pair ~ ("," ~ pair)* ~ "}"
// }
// pair = { string ~ ":" ~ value }

// array = {
// //    "[" ~ "]" |
//     "[" ~ value ~ ("," ~ value)* ~ "]"
// }
// value = _{ object | array | string | number | boolean | null | logical_binop}

// logical_binop = {
//     "(" ~ value ~ (">" | "<" | "==") ~ value ~ ")"
// }

// boolean = { "true" | "false" }

// null = { "null" }

// string = ${ "\"" ~ inner ~ "\"" }
// inner = @{ char* }
// char = {
//     !("\"" | "\\") ~ ANY
//     | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
//     | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
// }

// number = @{
//     "-"?
//     ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
//     ~ ("." ~ ASCII_DIGIT*)?
//     ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
// }

// json = _{ SOI ~ (object | array | logical_binop)* ~ EOI }
// .unwrap();
    // let pairs = pharos_parser::parse(
    //     Rule::json,
    //     r#"
    //      [[2],2,3,2,[1,3]]
    //      (4 < (5 < 2))
    //     "#,
    // )
    //println!("{:?}", pairs);